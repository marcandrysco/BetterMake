#!/bin/sh

sharedir="`dirname $0`/share"

##
# usage Function
#   Displays the usage information regarding the list of possible commands.
# Parameters
#   int fd = 1
#     Optional. The file descriptor number to send it to, often set to '2' for
#     error out.
#.

usage()
{
	if [ "$#" -eq 0 ] ; then
		fd=1
	else
		fd=$1
	fi

	cat <<EOF >&$fd
bmake command [options]

Possible commands are:
  install
  update
  target add
  target remove
  target list
  source add
  source remove
  source list
  help
EOF
}

##
# getopt_long Function
#   Parses a list of options, retrieving all of the values and flags. The
#   returned data is valid POSIX shell code that should be evaluated in order
#   to obtain the desired parameters. For each long parameter, a variable is
#   created with that parameter's name. For all short parameters without a
#   long equivalent, then a variable with that single character is created.
#   All non-option parameters are skipped (anything that does not begin with a
#   dash).
# Parameters
#   string shortopts
#     A list of short options that are accepted. Options followed by a colon
#     denote that those options require values, otherwise the option is a flag
#     of '1' or '0'.
#   string longopt ...
#     A set of long options in the form 'o,optname' where 'o' is the short
#     option equivalent and 'optname' is the full long name.
#   -- args ...
#     After the string '--', all of the parameters are placed after it.
#     Generally the value '"$@"' should be passed.
# Return Value
#   The returned text should be dirctly evaluated using the 'eval' build-in
#   function. All the parameters will be stored in their respective variables.
#   If an error occurs during processing, then the value 'err' will be set to
#   a text error message.
#.

getopt_long()
{
	local opt="$1" ; shift
	echo "$opt" | grep -E "^:" >/dev/null 2>/dev/null && warn="" || warn="yes"

	local param=" "
	while [ "$1" != "--" ]
	do
		param="$param $1 " ; shift
	done
	shift

	echo "params='';"
	local short="" ; local long=""

	for arg in "$@"
	do
		if [ -n "$short" ] ; then
			if [ -z "$long" ] ; then
				echo -n "$short='$arg';"
			else
				echo -n "$long='$arg';"
			fi

			short="" ; long=""

			continue
		fi

		case "$arg" in
		--*)
			long=`echo "$arg" | sed 's/--\([^=]*\)\(=.*\)\?/\1/'`
			short=`echo "$param" | sed -n "s/.* \\(.\\),$long .*/\1/p"`

			if [ -z "$short" ] && [ -n "$warn" ] ; then
				echo "err=\"invalid parameter '--$long'\";"
				return 1
			fi

			if echo "$opt" | grep "$short:" >/dev/null 2>/dev/null ; then
				test -n "${arg%%*=*}" && continue
				echo -n "$long='"`echo "${arg#*=}" | sed "s/'/'\\\\\\\\''/g"`"';"
			else
				if echo "$arg" | grep "=" >/dev/null 2>/dev/null && [ -n "warn" ]; then
					echo "err=\"parameter '-$short,--$long' does not take a value\";"
					return 1
				fi

				echo -n "$long=1;"
			fi

			short="" ; long=""
			;;

		-*)
			arg=`echo $arg | tail -c+2`
			local needval=""
			while [ -n "$arg" ]
			do
				short=`echo $arg | head -c1`

				if ! echo "$opt" | grep "$short" >/dev/null 2>/dev/null ; then
					echo "err=\"invalid parameter '-$short'\";"
					return 1
				fi

				long=`echo "$param" | sed -n "s/.* $short,\\([^ ]*\\) .*/\1/p"`
				arg=`echo $arg | tail -c+2`

				if ! echo "$opt" | grep "$short:" >/dev/null 2>/dev/null ; then
					if [ -z "$long" ] ; then
						echo -n "$short=1;"
					else
						echo -n "$long=1;"
					fi

					continue
				fi

				if [ -n "$arg" ] ; then
					if [ -z "$long" ] ; then
						echo -n "$short='$arg';"
					else
						echo -n "$long='$arg';"
					fi
				else
					needval="1"
				fi

				break
			done

			if [ -z "$needval" ] ; then
				short="" ; long=""
			fi
			;;

		*)
			;;
		esac
	done

	if [ -n "$long" ] ; then
		echo "err=\"parameter '-$short,--$long' needs a value\";"
		return 1
	elif [ -n "$short" ] ; then
		echo "err=\"parameter '-$short' needs a value\";"
		return 1
	fi

	echo "err='';"
	return 0
}

copyfile()
{
	echo "# Generated by BetterMake" > "$1"
	echo "# md5sum: "`md5sum "$sharedir/$1" | head -c32` >> "$1"
	echo >> "$1"
	cat "$sharedir/$1" >> "$1"

	test ! -z "$2" && chmod "$2" "$1"
}

quotify()
{
	echo "$1" | sed 's/"/\\"/g'
}

findtarget()
{
	target="`quotify "$2"`"
	grep -E "^[[:space:]]*Target[[:space:]]*\"$target\"[[:space:]]*$" "$1" >/dev/null 2>/dev/null
	return $?
}

quote()
{
	local str="$*"

	while [ 1 ]
	do
		local piece="${str%%\'*}"
		test "$piece" = "$str" && break
		printf "'%s'\\'" "$piece"
		str="${str#*\'}"
	done

	printf "'%s'" "$str"
}

dblquote()
{
	local str="$*"

	while [ 1 ]
	do
		local piece="${str%%[\\\"]*}"
		test "$piece" = "$str" && break
		local chr="${str#"$piece"}"
		str="${str#*[\\\"]}"
		printf %s%s "$piece" "\\${chr%"$str"}"
	done

	printf %s "$str"
}

undblquote()
{
	local str="$*"

	while [ 1 ]
	do
		local piece="${str%%\\?*}"
		test "$piece" = "$str" && break
		local chr="${str#*\\}"
		str="${chr#?}"
		printf %s%s "$piece" "${chr%"$str"}"
	done

	printf %s "$str"
}

target()
{
	cmd=$1; shift;

	case "$cmd" in
		add)
			target=""
			srcfile="sources"
			eval `getopt_long s: s,srcfile -- "$@"`
			if [ -n "$err" ] ; then echo "$err" ; exit 1 ; fi
			test -z "$target" && read -p"Target name: " target

			if findtarget "$srcfile" "$target" ; then
				echo "Target '$target' already exists" >&2
				exit 1
			fi

			for arg in "$@"
			do
				test -z "${arg%%-*}" && continue

				printf "Target\n\tOutput\t\"%s\"\nEndTarget\n" `dblquote "$arg"` >> "$srcfile"
			done

			;;

		*)
			usage 2
			exit 1
			;;
	esac
}

if [ "$#" -eq 0 ] ; then
	usage
	exit
fi

cmd=$1 ; shift

case "$cmd" in
	install)
		for file in "Makefile.in" "configure"
		do
			test -e "$file" || continue

			echo "$file already exists, cowardly giving up" >&2
			exit 1
		done

		copyfile "Makefile.in"
		copyfile "configure" 0755
		test ! -d mktests && mkdir mktests
		for file in "mktests/00-cc" "mktests/00-ld"
		do
			copyfile "$file" 0755
		done

		;;

	update)
		copyfile "Makefile.in"
		copyfile "configure" 0755
		test ! -d mktests && mkdir mktests
		for file in "mktests/00-cc" "mktests/00-ld"
		do
			copyfile "$file" 0755
		done

		;;
	
	target)
		target "$@"
		;;
	
	help | -? | --help)
		usage
		;;

	*)
		usage 2
		exit 1
		;;
esac
