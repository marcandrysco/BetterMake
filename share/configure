#!/bin/sh

##
# extract Function
#   Given a chunk of a file, it extracts the quoted option value given the
#   option name.
# Parameters
#   string text
#     The input text to be parsed.
#   string optname
#     The name of the option to extract.
#.

extract()
{
	printf %s "$1" | sed -n 's/^\s'"$2"'\s*"\(.*\)"\s*$/\1/p'
}

##
# quote Function
#   Given the input string, it places it within single quotes, making sure that
#   any single quotes within the string are properly escaped.
# Version
#   1.0
# Parameters
#   string input
#     The input text.
# Printed
#   Prints out the quoted string.
#.

quote()
{
	local str="$*"

	while [ 1 ]
	do
		local piece="${str%%\'*}"
		test "$piece" = "$str" && break
		printf "'%s'\\'" "$piece"
		str="${str#*\'}"
	done

	printf "'%s'" "$str"
}

##
# process_sources Function
#   Inputs the sources configuration file and produces the corresponding
#   makefile.
# Parameters
#   string infile
#     The name of the input sources file.
#   string outfile
#     The name of the output makefile.
#.

process_sources()
{
	local remaining="`cat "$1"`"

	rm -f "$2"

	clean=""	# Cleaning commands
	objlist=""	# List of all object files
	depdirlist=""	# List of dependency directories
	installdeps=""	# Dependencies for installation
	install=""	# Commands for installation
	clean=""	# Rules for cleaning

	while [ 1 ]
	do
		local copy="`printf %s "$remaining" | sed '/^\s*EndTarget\s*$/,$d'`"
		test "$copy" = "$remaining" && break

		cdeps="";				# C Dependencies
		targetdeps=""				# Target Dependencies
		cflags=" `extract "$copy" CFlags`"	# C Flags
		ldflags=" `extract "$copy" LDFlags`"	# Linker Flags

		# Add on global flags
		test "$CFLAGS" && cflags=" $CFLAGS$cflags"
		test "$LDFLAGS" && ldflags=" $LDFLAGS$ldflags"

		local target="`extract "$copy" Name`"
		local type="`extract "$copy" Type`"
		local local="`extract "$copy" Local`"
		local version="`extract "$copy" Version`"
		local sources="`extract "$copy" Source`"
		local obj="`printf %s "$sources" | sed 's/.c\(pp\)\?$/.o/'`"
		obj="`echo -n $obj`"

		test -z "$version" && version="0.0.0"
		local shortversion="${version%%.*}"

		case "$local" in
			[Tt][Rr][Uu][Ee] | [Yy][Ee][Ss] )
				prefix="$HOME"
				bindir="$HOME/bin"
				libdir="$HOME/bin"
				sharedir="$HOME/bin"
				cflags="$cflags -I\"$HOME/include\""
				ldflags="$ldflags -L\"$HOME/lib\" -Wl,-rpath=\"$HOME/lib\""
				;;

			[Ff][Aa][Ll][Ss][Ee] | [Nn][Oo] | "")
				;;

			*)
				echo "invalid local value \"$local\"" >&2
				exit 1
		esac

		# Precompiled header handling
		pch="`extract "$copy" PCH`"
		if [ -n "$pch" ] ; then
			printf '%s.gch: %s%s\n' "$pch" "$pch" "$cdeps" >> "$2"
			printf '\t$(bmake_PRECC)\n' >> "$2"
			printf '\t$(CC) $(CFLAGS)%s -c $< -o $@\n\n' "$cflags" >> "$2"

			clean="$clean`printf '\n\trm -f %s.gch\n' "$pch"`"
			cdeps="$cdeps $pch.gch"
		fi

		case "$type" in
			# Build an executable application
			"Application" | "" )
				printf 'bmake_all: %s\n\n' "$target" >> "$2"
				printf '%s: %s%s\n' "$target" "$obj" "$targetdeps" >> "$2"
				printf '\t%s\n\n' "`printf '$(LD) $^ -o $@ $(LDFLAGS)%s\n' "$ldflags"`" >> "$2"
				installdeps="$installdeps $target"
				install="$install`printf '\n\tinstall --mode 0755 -D %s "%s/%s"\n' "$target" "$bindir" "$target"`"
				clean="$clean`printf '\n\trm -f %s\n' "$target"`"
				local ldextra=''
				;;

			# Build a test application meant to be run during a make check
			"TestApplication")
				printf 'bmake_test: %s_test\n\n' "$target" >> "$2"
				printf '%s_test: %s\n' "$target" "$target" >> "$2"
				printf '\t@./%s || echo "**** %s failed ****"\n\n' "$target" "$target" >> "$2"
				printf '%s: %s %s| all\n' "$target" "$obj" "$deps">> "$2"
				printf '\t%s\n\n' "`printf '$(LD) %s -o $@ $(LDFLAGS)%s\n' "$obj" "$ldflags"`" >> "$2"
				clean="$clean`printf '\n\trm -f %s\n' "$target"`"
				local ldextra=''
				;;

			# Build a static and (optionally) a shared library
			"Library")
				printf 'bmake_all: lib%s.a\n\n' "$target" >> "$2"
				printf 'lib%s.a: %s\n\t%s\n\n' "$target" "$obj" "`printf '%sar rcs $@ $^' "$toolchain"`" >> "$2"
				installdeps="$installdeps lib$target.a"
				install="$install`printf '\n\tinstall --mode 0644 -D lib%s.a "%s/lib%s.a"' "$target" "$libdir" "$target"`"
				clean="$clean`printf '\n\trm -f lib%s.a' "$target"`"
				if [ "$dynlib" = "so" ] ; then
					printf 'bmake_all: lib%s.so.%s\n\n' "$target" "$version" >> "$2"
					printf 'lib%s.so.%s: %s\n' "$target" "$version" "$obj" >> "$2"
					printf '\t$(CC) -shared -Wl,-soname,lib%s.so.%s -o $@ $^%s\n' "$target" "$shortversion" "$ldflags" >> "$2"
					printf '\tln -fs lib%s.so.%s lib%s.so.%s\n' "$target" "$version" "$target" "$shortversion" >> "$2"
					printf '\tln -fs lib%s.so.%s lib%s.so\n\n' "$target" "$version" "$target" >> "$2"
					cflags="$cflags -fpic"
					installdeps="$installdeps `printf 'lib%s.so.%s' "$target" "$version"`"
					install="$install`printf '\n\tinstall --mode 0755 -D lib%s.so.%s "%s/lib%s.so.%s"' "$target" "$version" "$libdir" "$target" "$version"`"
					install="$install`printf '\n\tln -fs lib%s.so.%s "%s/lib%s.so"' "$target" "$version" "$libdir" "$target"`"
					install="$install`printf '\n\tln -fs lib%s.so.%s "%s/lib%s.so.%s"\n\n' "$target" "$version" "$libdir" "$target" "$shortversion"`"
					clean="$clean`printf '\n\trm -rf lib%s.so.%s lib%s.so.%s lib%s.so' "$target" "$version" "$target" "$shortversion" "$target"`"
				elif [ "$dynlib" = "dll" ] ; then
					printf 'bmake_all: lib%s.dll\n\n' "$target" >> "$2"
					printf 'lib%s.dll: %s\n' "$target" "$obj" >> "$2"
					printf '\t$(CC) -shared -Wl,--out-implib,lib%s.dll.a -Wl,--enable-auto-import -o $@ $^%s\n' "$target" "$ldflags" >> "$2"
					installdeps="$installdeps `printf 'lib%s.dll' "$target"`"
					install="$install`printf '\n\tinstall --mode 0644 -D lib%s.dll.a "%s/lib%s.dll.a"\n' "$target" "$libdir" "$target"`"
					install="$install`printf '\n\tinstall --mode 0755 -D lib%s.dll "%s/lib%s.dll"' "$target" "$bindir" "$target"`"
					clean="$clean`printf '\n\trm -rf lib%s.dll lib%s.dll.a' "$target" "$target"`"
				fi
				;;

			*)
				echo "invalid target type" >&2 ; exit 1 ;;
		esac

		for file in $sources
		do
			objfile="`printf %s "$file" | sed 's/.c\(pp\)\?$/.o/'`"
			objlist="$objlist $objfile"

			printf '%s: %s%s\n' "$objfile" "$file" "$cdeps" >> "$2"
			printf '\t$(bmake_PRECC)\n' >> "$2"
			printf '\t$(CC)%s -c $< -o $@ $(CFLAGS)\n\n' "$cflags" >> "$2"

			# Add depdir if not in list
			depdir="${file%/*}/deps"
			test "${depdirlist%" $depdir"}" = "$depdirlist" && depdirlist="$depdirlist $depdir"
		done

		remaining=`printf %s "$remaining" | sed '1,/^\s*EndTarget\s*$/d'`
	done

	test "$objlist" && clean="$clean`printf '\n\trm -f%s' "${objlist% }"`"
	test "$depdirlist" && clean="$clean`printf '\n\trm -rf%s' "${depdirlist% }"`"

	printf 'bmake_install:%s%s\n\n' "$installdeps" "$install" >> "$2"
	printf 'bmake_clean:%s\n\n' "$clean" >> "$2"
	printf '.PNOHY: bmake_install bmake_clean\n' >> "$2"
}

config="config.h"	# Configuration header
configlog="config.log"	# COnfigure script log

rm -f "$configlog"

test -e "src" && config="src/$config"

CFLAGS=""		# C compiler flags
LDFLAGS=""		# Linker flags
toolchain=""		# Toolchain used for compilation
prefix="/usr/local"	# Installation prefix
bindir=""		# Binary installation directory
libdir=""		# Library installation directory
sharedir=""		# Share installation directory

# Append arguments in config.args
test -f config.args && eval set -- "`cat config.args | sed 's/\s/ /g'`"

for opt in "$@"
do
	if [ -z "$optname" ] ; then
		if [ "$opt" != "${opt%%=*}" ] ; then
			optname=${opt%%=*}
			opt=${opt#*=} 
		else
			optname="$opt"
			unset opt
		fi
	fi

	case "$optname" in
		--build)
			test -z "$opt" && continue ; build="$opt" ;;

		--host)
			test -z "$opt" && continue ; host="$opt" ;;

		--prefix | --libdir | --bindir | --toolchain)
			test -z "$opt" && continue ; eval "${optname#--}=`quote "$opt"`" ;;

		CFLAGS | LDFLAGS )
			test -z "$opt" && continue ; eval "$optname=`quote "$opt"`" ;;

		*)
			echo "invalid option $optname"
			exit 1
			;;
	esac

	unset optname
done

test -z "$bindir" && bindir="$prefix/bin"
test -z "$libdir" && libdir="$prefix/lib"
test -z "$sharedir" && sharedir="$prefix/share"
test "$toolchain" && toolchain="$toolchain-"

test ! -z $optname && echo "'$optname' requires parameter" && exit 1

test -z "$prefix" && prefix="/usr/bin"

unset BMAKE_DECL

build_config_h()
{
	cat <<EOF > "$config"
#ifndef CONFIG_H
#define CONFIG_H

#define BMAKE__PATH_PREFIX	"$prefix"
#define BMAKE__PATH_BIN		"$bindir"
#define BMAKE__PATH_LIB		"$libdir"
#define BMAKE__PATH_SHARE	"$sharedir"

EOF
}

build_config_h

for script in mktests/[0-9][0-9]*
do
	test ! -f "$script" && continue
	rm -f mktests/tmp*
	. $script || exit $?
done
rm -f mktests/tmp*

echo "#endif" >> "$config"

process_sources sources sources.mk

# Build config.status file for reconfiguration
rm -rf config.status
echo -n "$0" > config.status
for param in "$@"
do
	echo -n " `quote "$param"`" >> config.status
done
echo >> config.status
chmod +x config.status

if [ -e "$make" ] ; then
	if ! rm -f "$make" < /dev/null > /dev/null 2> /dev/null ; then
		echo Unable to remove "$make"
		exit
	fi
fi

cat <<EOF > "Makefile"
# autogenerated by configure script
bmake_PRECC =
bmake_CFLAGS = 
bmake_LDFLAGS = 
bmake_reconfigure = $reconf
bmake_PREFIX = $prefix
$BMAKE_DECL
# end autogenerated content
EOF

cat "Makefile.in" >> "Makefile"

cat <<EOF >> "Makefile"
# autogenerated by configure script
bmake-all:

bmake-clean:
	rm Makefile $config
# end autogenerated content
EOF
